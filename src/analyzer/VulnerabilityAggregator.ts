import type * as vscode from 'vscode';
import type {
  AggregatedVulnerability,
  VulnerabilityAggregator as IVulnerabilityAggregator,
  Vulnerability,
  VulnerabilityClient,
  VulnerabilitySource,
} from '../types';
import type { RequestQueue } from '../utils/RequestQueue';

/**
 * Aggregates vulnerability data from multiple sources
 * Handles deduplication, severity merging, and partial failures
 */
export class VulnerabilityAggregator implements IVulnerabilityAggregator {
  private clients: Map<VulnerabilitySource, VulnerabilityClient>;
  private activeSources: VulnerabilitySource[];
  private outputChannel: vscode.OutputChannel;
  private primarySource: 'osv' | 'github';
  private osvClient?: VulnerabilityClient;
  private githubClient?: VulnerabilityClient;

  constructor(
    clients: Map<VulnerabilitySource, VulnerabilityClient>,
    _requestQueue: RequestQueue,
    outputChannel: vscode.OutputChannel,
    initialSources?: VulnerabilitySource[],
    primarySource: 'osv' | 'github' = 'osv'
  ) {
    this.clients = clients;
    this.outputChannel = outputChannel;
    this.primarySource = primarySource;

    // Store references to specific clients for easy access
    this.osvClient = clients.get('osv');
    this.githubClient = clients.get('github');

    // Initialize with all available sources or specified sources
    this.activeSources = initialSources || Array.from(clients.keys());

    this.log(
      'info',
      `VulnerabilityAggregator initialized with sources: ${this.activeSources.join(', ')}, primary: ${this.primarySource}`
    );
  }

  /**
   * Fetches vulnerabilities from all configured sources
   * Uses batch method internally for consistency
   * @param packageName Package to check
   * @param version Installed version
   * @returns Aggregated and deduplicated vulnerabilities
   */
  async getAggregatedVulnerabilities(
    packageName: string,
    version: string,
    bypassCache: boolean = false
  ): Promise<AggregatedVulnerability[]> {
    this.log('info', `Aggregating vulnerabilities for ${packageName}@${version}`);

    // Use batch method with single package for consistency
    const dependency: import('../types').Dependency = {
      name: packageName,
      version,
      versionConstraint: version,
      isDev: false,
    };

    const batchResults = await this.getBatchAggregatedVulnerabilities([dependency], bypassCache);
    const vulnerabilities = batchResults.get(packageName) || [];

    this.log(
      'info',
      `Aggregated ${vulnerabilities.length} unique vulnerabilities for ${packageName}@${version}`
    );

    return vulnerabilities;
  }

  /**
   * Optimizes connection pool for OSV client based on project size
   * Should be called before starting batch analysis
   * @param totalDependencies Total number of dependencies in project
   */
  optimizeConnectionPool(totalDependencies: number): void {
    // Optimize OSV client connection pool if available
    if (this.osvClient && 'optimizeConnectionPool' in this.osvClient) {
      (this.osvClient as { optimizeConnectionPool: (size: number) => void }).optimizeConnectionPool(
        totalDependencies
      );
      this.log('info', `Connection pool optimized for ${totalDependencies} dependencies`);
    }
  }

  /**
   * Fetches vulnerabilities for multiple packages from all configured sources
   * Uses primary/fallback logic: OSV first, GitHub on failure
   * @param dependencies Array of dependencies to check
   * @returns Map of package names to their aggregated vulnerabilities
   */
  async getBatchAggregatedVulnerabilities(
    dependencies: import('../types').Dependency[],
    bypassCache: boolean = false
  ): Promise<Map<string, AggregatedVulnerability[]>> {
    this.log(
      'info',
      `Aggregating vulnerabilities for ${dependencies.length} packages in batch mode (primary: ${this.primarySource})`
    );

    let osvResults: Map<string, import('../types').Vulnerability[]> | null = null;
    let githubResults: Map<string, import('../types').Vulnerability[]> | null = null;
    let osvError: Error | null = null;

    const shouldQueryOSV = this.activeSources.includes('osv') && this.osvClient;
    const shouldQueryGitHub = this.activeSources.includes('github') && this.githubClient;

    // If OSV is in active sources but client is missing, throw error
    if (this.activeSources.includes('osv') && !this.osvClient) {
      throw new Error('OSV client not available');
    }

    // Query OSV if it's in active sources
    if (shouldQueryOSV) {
      try {
        osvResults = await this.queryOSV(dependencies, bypassCache);
      } catch (error) {
        osvError = error as Error;
        this.log('warn', 'OSV query failed', error);
      }
    }

    // Query GitHub if it's in active sources
    if (shouldQueryGitHub) {
      try {
        githubResults = await this.queryGitHub(dependencies, bypassCache);
      } catch (error) {
        this.log('warn', 'GitHub query failed', error);
      }
    }

    // If OSV is primary and failed, and GitHub wasn't queried but is available, use it as fallback
    if (
      this.primarySource === 'osv' &&
      osvError &&
      !shouldQueryGitHub &&
      this.githubClient &&
      this.shouldFallbackToGitHub(osvResults, osvError)
    ) {
      this.log('info', 'OSV failed, falling back to GitHub Advisory');
      try {
        githubResults = await this.queryGitHub(dependencies);
      } catch (error) {
        this.log('warn', 'GitHub fallback also failed', error);
      }
    }

    // Organize results by package
    const packageResults = new Map<
      string,
      Array<{
        source: VulnerabilitySource;
        vulnerabilities: import('../types').Vulnerability[];
        success: boolean;
      }>
    >();

    // Initialize all packages
    for (const dep of dependencies) {
      packageResults.set(dep.name, []);
    }

    // Collect OSV results
    if (osvResults) {
      for (const [packageName, vulns] of osvResults) {
        const pkgResults = packageResults.get(packageName);
        if (pkgResults) {
          pkgResults.push({ source: 'osv', vulnerabilities: vulns, success: true });
        }
      }
    }

    // Collect GitHub results
    if (githubResults) {
      for (const [packageName, vulns] of githubResults) {
        const pkgResults = packageResults.get(packageName);
        if (pkgResults) {
          pkgResults.push({ source: 'github', vulnerabilities: vulns, success: true });
        }
      }
    }

    // Deduplicate and merge for each package
    const aggregatedResults = new Map<string, AggregatedVulnerability[]>();
    for (const [packageName, sourceData] of packageResults) {
      const aggregated = this.deduplicateAndMerge(sourceData);
      aggregatedResults.set(packageName, aggregated);
      this.log('info', `Aggregated ${aggregated.length} vulnerabilities for ${packageName}`);
    }

    this.log('info', `Batch aggregation complete: processed ${aggregatedResults.size} packages`);

    return aggregatedResults;
  }

  /**
   * Queries OSV.dev as primary source
   */
  private async queryOSV(
    dependencies: import('../types').Dependency[],
    bypassCache: boolean = false
  ): Promise<Map<string, import('../types').Vulnerability[]>> {
    if (!this.osvClient) {
      throw new Error('OSV client not available');
    }

    this.log('info', `Querying OSV for ${dependencies.length} packages`);

    if (this.osvClient.getBatchVulnerabilities) {
      const results = await this.osvClient.getBatchVulnerabilities(dependencies, bypassCache);
      this.log('info', `OSV returned results for ${results.size} packages`);
      return results;
    }

    // Fallback to individual requests if batch not supported
    this.log('info', 'OSV does not support batch, falling back to individual requests');
    const results = new Map<string, import('../types').Vulnerability[]>();
    for (const dep of dependencies) {
      try {
        const vulns = await this.osvClient.getVulnerabilities(dep.name, dep.version, bypassCache);
        results.set(dep.name, vulns);
      } catch (error) {
        this.log('warn', `Failed to query OSV for ${dep.name}`, error);
        results.set(dep.name, []);
      }
    }
    return results;
  }

  /**
   * Queries GitHub Advisory as fallback
   */
  private async queryGitHub(
    dependencies: import('../types').Dependency[],
    bypassCache: boolean = false
  ): Promise<Map<string, import('../types').Vulnerability[]>> {
    if (!this.githubClient) {
      throw new Error('GitHub client not available');
    }

    this.log('info', `Querying GitHub Advisory for ${dependencies.length} packages`);

    if (this.githubClient.getBatchVulnerabilities) {
      const results = await this.githubClient.getBatchVulnerabilities(dependencies, bypassCache);
      this.log('info', `GitHub returned results for ${results.size} packages`);
      return results;
    }

    // Fallback to individual requests if batch not supported
    this.log('info', 'GitHub does not support batch, falling back to individual requests');
    const results = new Map<string, import('../types').Vulnerability[]>();
    for (const dep of dependencies) {
      try {
        const vulns = await this.githubClient.getVulnerabilities(
          dep.name,
          dep.version,
          bypassCache
        );
        results.set(dep.name, vulns);
      } catch (error) {
        this.log('warn', `Failed to query GitHub for ${dep.name}`, error);
        results.set(dep.name, []);
      }
    }
    return results;
  }

  /**
   * Determines if fallback is needed based on OSV results
   */
  private shouldFallbackToGitHub(
    osvResults: Map<string, import('../types').Vulnerability[]> | null,
    error?: Error | null
  ): boolean {
    // Fallback if OSV request failed completely
    if (error) {
      this.log('warn', 'OSV request failed, falling back to GitHub', error);
      return true;
    }

    // Don't fallback if OSV succeeded (even with some empty results)
    if (osvResults && osvResults.size > 0) {
      return false;
    }

    // Fallback if OSV returned no results at all (suspicious)
    if (!osvResults || osvResults.size === 0) {
      this.log('warn', 'OSV returned no results, falling back to GitHub');
      return true;
    }

    return false;
  }

  /**
   * Deduplicates and merges vulnerabilities from multiple sources
   */
  private deduplicateAndMerge(
    results: Array<{
      source: VulnerabilitySource;
      vulnerabilities: Vulnerability[];
      success: boolean;
    }>
  ): AggregatedVulnerability[] {
    // Create a map to deduplicate by vulnerability ID (CVE or GHSA)
    const vulnMap = new Map<string, AggregatedVulnerability>();

    for (const result of results) {
      for (const vuln of result.vulnerabilities) {
        const existing = vulnMap.get(vuln.id);

        if (existing) {
          // Merge with existing vulnerability
          this.mergeVulnerability(existing, vuln, result.source);
        } else {
          // Create new aggregated vulnerability
          const aggregated: AggregatedVulnerability = {
            ...vuln,
            sources: [result.source],
            highestSeverity: vuln.severity,
            allSeverities: {
              [result.source]: vuln.severity,
            },
          };
          vulnMap.set(vuln.id, aggregated);
        }
      }
    }

    return Array.from(vulnMap.values());
  }

  /**
   * Merges a vulnerability from a new source into an existing aggregated vulnerability
   */
  private mergeVulnerability(
    existing: AggregatedVulnerability,
    newVuln: Vulnerability,
    source: VulnerabilitySource
  ): void {
    // Add source if not already present
    if (!existing.sources.includes(source)) {
      existing.sources.push(source);
    }

    // Store severity from this source
    existing.allSeverities[source] = newVuln.severity;

    // Update highest severity if this one is higher
    const newSeverityLevel = this.getSeverityLevel(newVuln.severity);
    const currentSeverityLevel = this.getSeverityLevel(existing.highestSeverity);

    if (newSeverityLevel > currentSeverityLevel) {
      existing.highestSeverity = newVuln.severity;
      existing.severity = newVuln.severity; // Update main severity field too
    }

    // Merge affectedVersions
    if (newVuln.affectedVersions && newVuln.affectedVersions !== 'Unknown') {
      if (!existing.affectedVersions || existing.affectedVersions === 'Unknown') {
        existing.affectedVersions = newVuln.affectedVersions;
      } else {
        // Split by ' || ' to handle existing merged ranges
        const existingRanges = existing.affectedVersions.split(' || ').map((r) => r.trim());
        const newRanges = newVuln.affectedVersions.split(' || ').map((r) => r.trim());

        // Add new ranges if they don't exist
        for (const range of newRanges) {
          if (!existingRanges.includes(range)) {
            existingRanges.push(range);
          }
        }

        existing.affectedVersions = existingRanges.join(' || ');
      }
    }

    // Merge CVSS data intelligently
    this.mergeCVSSData(existing, newVuln, source);

    if (newVuln.patchedVersions && !existing.patchedVersions) {
      existing.patchedVersions = newVuln.patchedVersions;
    }

    // Merge references (deduplicate)
    if (newVuln.references) {
      const existingRefs = new Set(existing.references);
      for (const ref of newVuln.references) {
        if (!existingRefs.has(ref)) {
          existing.references.push(ref);
        }
      }
    }

    // Merge CWE IDs (deduplicate)
    if (newVuln.cweIds) {
      if (!existing.cweIds) {
        existing.cweIds = [];
      }
      const existingCwes = new Set(existing.cweIds);
      for (const cwe of newVuln.cweIds) {
        if (!existingCwes.has(cwe)) {
          existing.cweIds.push(cwe);
        }
      }
    }

    // Update exploit availability (if any source reports it)
    if (newVuln.exploitAvailable && !existing.exploitAvailable) {
      existing.exploitAvailable = true;
    }

    // Use earliest published date
    if (newVuln.publishedDate && existing.publishedDate) {
      if (newVuln.publishedDate < existing.publishedDate) {
        existing.publishedDate = newVuln.publishedDate;
      }
    } else if (newVuln.publishedDate) {
      existing.publishedDate = newVuln.publishedDate;
    }

    // Use latest modified date
    if (newVuln.lastModifiedDate && existing.lastModifiedDate) {
      if (newVuln.lastModifiedDate > existing.lastModifiedDate) {
        existing.lastModifiedDate = newVuln.lastModifiedDate;
      }
    } else if (newVuln.lastModifiedDate) {
      existing.lastModifiedDate = newVuln.lastModifiedDate;
    }
  }

  /**
   * Converts severity string to numeric level for comparison
   * Higher number = more severe
   */
  private getSeverityLevel(severity: string): number {
    switch (severity.toLowerCase()) {
      case 'critical':
        return 4;
      case 'high':
        return 3;
      case 'medium':
      case 'moderate':
        return 2;
      case 'low':
        return 1;
      default:
        return 0;
    }
  }

  /**
   * Updates primary source configuration
   */
  setPrimarySource(source: 'osv' | 'github'): void {
    this.primarySource = source;
    this.log('info', `Primary vulnerability source changed to: ${source}`);
  }

  /**
   * Configures which databases to query
   */
  configureSources(sources: VulnerabilitySource[]): void {
    // Validate that at least one source is enabled
    if (sources.length === 0) {
      this.log('warn', 'No vulnerability sources configured, using all available sources');
      this.activeSources = Array.from(this.clients.keys());
      return;
    }

    // Filter to only include sources that have clients
    this.activeSources = sources.filter((source) => {
      const hasClient = this.clients.has(source);
      if (!hasClient) {
        this.log('warn', `Source ${source} configured but no client available`);
      }
      return hasClient;
    });

    this.log('info', `Active vulnerability sources: ${this.activeSources.join(', ')}`);
  }

  /**
   * Merges CVSS data from multiple sources
   * Prefers higher CVSS version (v4 > v3.1 > v3.0 > v2)
   * If versions equal, prefers higher score
   */
  private mergeCVSSData(
    existing: AggregatedVulnerability,
    newVuln: Vulnerability,
    source: VulnerabilitySource
  ): void {
    // If only one has CVSS, use that one
    if (!existing.cvssScore && newVuln.cvssScore) {
      existing.cvssScore = newVuln.cvssScore;
      existing.cvssVersion = newVuln.cvssVersion;
      existing.vectorString = newVuln.vectorString;
      this.log(
        'info',
        `Using CVSS data from ${source}: ${newVuln.cvssScore} (${newVuln.cvssVersion})`
      );
      return;
    }

    if (existing.cvssScore && !newVuln.cvssScore) {
      // Keep existing
      return;
    }

    if (!existing.cvssScore && !newVuln.cvssScore) {
      // Neither has CVSS
      return;
    }

    // Both have CVSS - compare versions
    const existingVersion = this.parseCVSSVersion(existing.cvssVersion);
    const newVersion = this.parseCVSSVersion(newVuln.cvssVersion);

    if (newVersion > existingVersion) {
      // New version is higher - use it
      existing.cvssScore = newVuln.cvssScore;
      existing.cvssVersion = newVuln.cvssVersion;
      existing.vectorString = newVuln.vectorString;
      this.log(
        'info',
        `Preferring CVSS v${newVuln.cvssVersion} from ${source} over v${existing.cvssVersion}`
      );
    } else if (newVersion === existingVersion && newVuln.cvssScore && existing.cvssScore) {
      // Same version - use higher score
      if (newVuln.cvssScore > existing.cvssScore) {
        existing.cvssScore = newVuln.cvssScore;
        existing.cvssVersion = newVuln.cvssVersion;
        existing.vectorString = newVuln.vectorString;
        this.log(
          'info',
          `Preferring higher CVSS score ${newVuln.cvssScore} from ${source} over ${existing.cvssScore}`
        );
      }
    }
  }

  /**
   * Parses CVSS version string to numeric value for comparison
   */
  private parseCVSSVersion(version?: string): number {
    if (!version) return 0;

    switch (version) {
      case '4.0':
        return 4;
      case '3.1':
        return 3.1;
      case '3.0':
        return 3;
      case '2.0':
        return 2;
      default:
        return 0;
    }
  }

  /**
   * Logs messages to the output channel
   */
  private log(level: 'info' | 'warn' | 'error', message: string, data?: unknown): void {
    const timestamp = new Date().toISOString();
    const logMessage = `[${timestamp}] [${level.toUpperCase()}] VulnerabilityAggregator: ${message}`;
    this.outputChannel.appendLine(logMessage);

    if (data) {
      if (data instanceof Error) {
        this.outputChannel.appendLine(`  Error: ${data.message}`);
        if (data.stack) {
          this.outputChannel.appendLine(`  Stack: ${data.stack}`);
        }
      } else {
        this.outputChannel.appendLine(JSON.stringify(data, null, 2));
      }
    }
  }
}
