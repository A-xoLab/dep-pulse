import * as fc from 'fast-check';
import { beforeEach, describe, expect, it, vi } from 'vitest';
import type * as vscode from 'vscode';
import { getPropertyTestRuns } from '../test-setup';
import type { Dependency, Vulnerability, VulnerabilityClient, VulnerabilitySource } from '../types';
import type { RequestQueue } from '../utils/RequestQueue';
import { VulnerabilityAggregator } from './VulnerabilityAggregator';

// Mock output channel
const createMockOutputChannel = (): vscode.OutputChannel => ({
  name: 'test',
  append: vi.fn(),
  appendLine: vi.fn(),
  replace: vi.fn(),
  clear: vi.fn(),
  show: vi.fn(),
  hide: vi.fn(),
  dispose: vi.fn(),
});

// Mock request queue
const createMockRequestQueue = (): RequestQueue =>
  ({
    enqueue: vi.fn().mockImplementation((fn) => fn()),
    clear: vi.fn(),
    getQueueSize: vi.fn().mockReturnValue(0),
    getActiveCount: vi.fn().mockReturnValue(0),
  }) as unknown as RequestQueue;

describe('VulnerabilityAggregator - Property-Based Tests', () => {
  let mockOutputChannel: vscode.OutputChannel;
  let mockRequestQueue: RequestQueue;

  beforeEach(() => {
    mockOutputChannel = createMockOutputChannel();
    mockRequestQueue = createMockRequestQueue();
  });

  /**
   * Property 11: GitHub fallback exclusion on success
   * For any successful OSV response (even if some packages have zero vulnerabilities),
   * the VulnerabilityAggregator should NOT query GitHub Advisory
   * Validates: Requirements 5.5
   * Feature: osv-integration, Property 11: GitHub fallback exclusion on success
   */
  describe('Property 11: GitHub fallback exclusion on success', () => {
    it('should not query GitHub when OSV returns successful results for any set of dependencies', async () => {
      await fc.assert(
        fc.asyncProperty(
          // Generate random dependencies
          fc.array(
            fc.record({
              name: fc.string({ minLength: 1, maxLength: 30 }),
              version: fc.string({ minLength: 1, maxLength: 20 }),
              versionConstraint: fc.string({ minLength: 1, maxLength: 20 }),
              isDev: fc.boolean(),
            }),
            { minLength: 1, maxLength: 50 }
          ),
          // Generate random OSV results (some packages may have 0 vulnerabilities)
          fc.array(
            fc.record({
              packageName: fc.string({ minLength: 1, maxLength: 30 }),
              vulnerabilities: fc.array(
                fc.record({
                  id: fc.oneof(
                    fc.string({ minLength: 10, maxLength: 30 }).map((s) => `GHSA-${s}`),
                    fc.string({ minLength: 10, maxLength: 20 }).map((s) => `CVE-2023-${s}`)
                  ),
                  title: fc.string({ minLength: 10, maxLength: 100 }),
                  severity: fc.constantFrom('critical', 'high', 'medium', 'low'),
                  affectedVersions: fc.string({ minLength: 1, maxLength: 20 }),
                  description: fc.string({ minLength: 20, maxLength: 200 }),
                  references: fc.array(fc.webUrl(), { minLength: 0, maxLength: 3 }),
                  publishedDate: fc.date(),
                  lastModifiedDate: fc.date(),
                }),
                { minLength: 0, maxLength: 5 } // Allow 0 vulnerabilities
              ),
            }),
            { minLength: 1, maxLength: 50 }
          ),
          async (dependencies: Dependency[], osvResultsData) => {
            // Create OSV results map
            const osvResults = new Map<string, Vulnerability[]>();
            for (const data of osvResultsData) {
              osvResults.set(data.packageName, data.vulnerabilities);
            }

            // Ensure all dependencies have results (even if empty)
            for (const dep of dependencies) {
              if (!osvResults.has(dep.name)) {
                osvResults.set(dep.name, []);
              }
            }

            // Create mock clients
            const osvGetBatchMock = vi.fn().mockResolvedValue(osvResults);
            const githubGetBatchMock = vi.fn().mockResolvedValue(new Map());

            const osvClient: VulnerabilityClient = {
              getVulnerabilities: vi.fn(),
              getBatchVulnerabilities: osvGetBatchMock,
            };

            const githubClient: VulnerabilityClient = {
              getVulnerabilities: vi.fn(),
              getBatchVulnerabilities: githubGetBatchMock,
            };

            const clients = new Map<VulnerabilitySource, VulnerabilityClient>([
              ['osv', osvClient],
              ['github', githubClient],
            ]);

            // Only OSV in activeSources - GitHub should only be used as fallback
            const aggregator = new VulnerabilityAggregator(
              clients,
              mockRequestQueue,
              mockOutputChannel,
              ['osv'],
              'osv' // OSV is primary
            );

            // Execute batch query
            await aggregator.getBatchAggregatedVulnerabilities(dependencies);

            // Verify OSV was called
            expect(osvGetBatchMock).toHaveBeenCalledTimes(1);
            expect(osvGetBatchMock).toHaveBeenCalledWith(dependencies, false);

            // Verify GitHub was NOT called (even if some packages have 0 vulnerabilities)
            expect(githubGetBatchMock).not.toHaveBeenCalled();
          }
        ),
        { numRuns: getPropertyTestRuns(100, 20) }
      );
    });

    it('should not query GitHub when OSV returns empty results for all packages', async () => {
      await fc.assert(
        fc.asyncProperty(
          // Generate random dependencies
          fc.array(
            fc.record({
              name: fc.string({ minLength: 1, maxLength: 30 }),
              version: fc.string({ minLength: 1, maxLength: 20 }),
              versionConstraint: fc.string({ minLength: 1, maxLength: 20 }),
              isDev: fc.boolean(),
            }),
            { minLength: 1, maxLength: 20 }
          ),
          async (dependencies: Dependency[]) => {
            // Create OSV results with all empty arrays
            const osvResults = new Map<string, Vulnerability[]>();
            for (const dep of dependencies) {
              osvResults.set(dep.name, []);
            }

            // Create mock clients
            const osvGetBatchMock = vi.fn().mockResolvedValue(osvResults);
            const githubGetBatchMock = vi.fn().mockResolvedValue(new Map());

            const osvClient: VulnerabilityClient = {
              getVulnerabilities: vi.fn(),
              getBatchVulnerabilities: osvGetBatchMock,
            };

            const githubClient: VulnerabilityClient = {
              getVulnerabilities: vi.fn(),
              getBatchVulnerabilities: githubGetBatchMock,
            };

            const clients = new Map<VulnerabilitySource, VulnerabilityClient>([
              ['osv', osvClient],
              ['github', githubClient],
            ]);

            // Only OSV in activeSources - GitHub should only be used as fallback
            const aggregator = new VulnerabilityAggregator(
              clients,
              mockRequestQueue,
              mockOutputChannel,
              ['osv'],
              'osv' // OSV is primary
            );

            // Execute batch query
            await aggregator.getBatchAggregatedVulnerabilities(dependencies);

            // Verify OSV was called
            expect(osvGetBatchMock).toHaveBeenCalledTimes(1);

            // Verify GitHub was NOT called (OSV succeeded, even with all empty results)
            expect(githubGetBatchMock).not.toHaveBeenCalled();
          }
        ),
        { numRuns: getPropertyTestRuns(50, 10) }
      );
    });

    it('should query GitHub only when OSV fails with error', async () => {
      await fc.assert(
        fc.asyncProperty(
          // Generate random dependencies
          fc.array(
            fc.record({
              name: fc.string({ minLength: 1, maxLength: 30 }),
              version: fc.string({ minLength: 1, maxLength: 20 }),
              versionConstraint: fc.string({ minLength: 1, maxLength: 20 }),
              isDev: fc.boolean(),
            }),
            { minLength: 1, maxLength: 20 }
          ),
          async (dependencies: Dependency[]) => {
            // Create GitHub results
            const githubResults = new Map<string, Vulnerability[]>();
            for (const dep of dependencies) {
              githubResults.set(dep.name, []);
            }

            // Create mock clients - OSV throws error
            const osvGetBatchMock = vi.fn().mockRejectedValue(new Error('OSV API error'));
            const githubGetBatchMock = vi.fn().mockResolvedValue(githubResults);

            const osvClient: VulnerabilityClient = {
              getVulnerabilities: vi.fn(),
              getBatchVulnerabilities: osvGetBatchMock,
            };

            const githubClient: VulnerabilityClient = {
              getVulnerabilities: vi.fn(),
              getBatchVulnerabilities: githubGetBatchMock,
            };

            const clients = new Map<VulnerabilitySource, VulnerabilityClient>([
              ['osv', osvClient],
              ['github', githubClient],
            ]);

            // Only OSV in activeSources - GitHub should only be used as fallback
            const aggregator = new VulnerabilityAggregator(
              clients,
              mockRequestQueue,
              mockOutputChannel,
              ['osv'],
              'osv' // OSV is primary
            );

            // Execute batch query
            await aggregator.getBatchAggregatedVulnerabilities(dependencies);

            // Verify OSV was called
            expect(osvGetBatchMock).toHaveBeenCalledTimes(1);

            // Verify GitHub WAS called as fallback
            expect(githubGetBatchMock).toHaveBeenCalledTimes(1);
            expect(githubGetBatchMock).toHaveBeenCalledWith(dependencies, false);
          }
        ),
        { numRuns: getPropertyTestRuns(50, 10) }
      );
    });

    it('should not query GitHub when primary source is github', async () => {
      await fc.assert(
        fc.asyncProperty(
          // Generate random dependencies
          fc.array(
            fc.record({
              name: fc.string({ minLength: 1, maxLength: 30 }),
              version: fc.string({ minLength: 1, maxLength: 20 }),
              versionConstraint: fc.string({ minLength: 1, maxLength: 20 }),
              isDev: fc.boolean(),
            }),
            { minLength: 1, maxLength: 20 }
          ),
          async (dependencies: Dependency[]) => {
            // Create GitHub results
            const githubResults = new Map<string, Vulnerability[]>();
            for (const dep of dependencies) {
              githubResults.set(dep.name, []);
            }

            // Create mock clients
            const osvGetBatchMock = vi.fn().mockResolvedValue(new Map());
            const githubGetBatchMock = vi.fn().mockResolvedValue(githubResults);

            const osvClient: VulnerabilityClient = {
              getVulnerabilities: vi.fn(),
              getBatchVulnerabilities: osvGetBatchMock,
            };

            const githubClient: VulnerabilityClient = {
              getVulnerabilities: vi.fn(),
              getBatchVulnerabilities: githubGetBatchMock,
            };

            const clients = new Map<VulnerabilitySource, VulnerabilityClient>([
              ['osv', osvClient],
              ['github', githubClient],
            ]);

            // Only GitHub in activeSources when GitHub is primary
            const aggregator = new VulnerabilityAggregator(
              clients,
              mockRequestQueue,
              mockOutputChannel,
              ['github'],
              'github' // GitHub is primary
            );

            // Execute batch query
            await aggregator.getBatchAggregatedVulnerabilities(dependencies);

            // Verify OSV was NOT called
            expect(osvGetBatchMock).not.toHaveBeenCalled();

            // Verify GitHub WAS called as primary
            expect(githubGetBatchMock).toHaveBeenCalledTimes(1);
            expect(githubGetBatchMock).toHaveBeenCalledWith(dependencies, false);
          }
        ),
        { numRuns: getPropertyTestRuns(50, 10) }
      );
    });
  });

  /**
   * Property 15: Graceful degradation on partial failure
   * For any batch where some packages fail after all retries,
   * the client should continue processing other packages and return results for successful ones
   * Validates: Requirements 7.5
   * Feature: osv-integration, Property 15: Graceful degradation on partial failure
   */
  describe('Property 15: Graceful degradation on partial failure', () => {
    it('should return results for successful packages even when some fail', async () => {
      await fc.assert(
        fc.asyncProperty(
          // Generate random dependencies
          fc.array(
            fc.record({
              name: fc.string({ minLength: 1, maxLength: 30 }),
              version: fc.string({ minLength: 1, maxLength: 20 }),
              versionConstraint: fc.string({ minLength: 1, maxLength: 20 }),
              isDev: fc.boolean(),
            }),
            { minLength: 2, maxLength: 20 } // At least 2 packages
          ),
          // Generate which packages should succeed (at least 1)
          fc.integer({ min: 1, max: 100 }),
          async (dependencies: Dependency[], successPercentage: number) => {
            // Determine which packages succeed based on percentage
            const osvResults = new Map<string, Vulnerability[]>();

            for (let i = 0; i < dependencies.length; i++) {
              const dep = dependencies[i];
              // Use deterministic success based on index and percentage
              const shouldSucceed = (i * 100) / dependencies.length < successPercentage;

              if (shouldSucceed) {
                // Successful package - return vulnerabilities (may be empty)
                osvResults.set(dep.name, [
                  {
                    id: `CVE-2023-${i}`,
                    title: `Vulnerability for ${dep.name}`,
                    severity: 'medium',
                    affectedVersions: '< 2.0.0',
                    description: 'Test vulnerability',
                    references: [],
                    publishedDate: new Date(),
                    lastModifiedDate: new Date(),
                  },
                ]);
              }
              // Failed packages are not in the map
            }

            // Ensure at least one package succeeds
            if (osvResults.size === 0 && dependencies.length > 0) {
              osvResults.set(dependencies[0].name, []);
            }

            // Create mock clients
            const osvGetBatchMock = vi.fn().mockResolvedValue(osvResults);
            const githubGetBatchMock = vi.fn().mockResolvedValue(new Map());

            const osvClient: VulnerabilityClient = {
              getVulnerabilities: vi.fn(),
              getBatchVulnerabilities: osvGetBatchMock,
            };

            const githubClient: VulnerabilityClient = {
              getVulnerabilities: vi.fn(),
              getBatchVulnerabilities: githubGetBatchMock,
            };

            const clients = new Map<VulnerabilitySource, VulnerabilityClient>([
              ['osv', osvClient],
              ['github', githubClient],
            ]);

            const aggregator = new VulnerabilityAggregator(
              clients,
              mockRequestQueue,
              mockOutputChannel,
              ['osv', 'github'],
              'osv'
            );

            // Execute batch query
            const results = await aggregator.getBatchAggregatedVulnerabilities(dependencies);

            // Verify results were returned
            expect(results).toBeDefined();
            expect(results.size).toBeGreaterThan(0);

            // Verify all successful packages are in results
            for (const [packageName] of osvResults) {
              expect(results.has(packageName)).toBe(true);
            }

            // Verify results contain aggregated vulnerabilities
            for (const [, vulns] of results) {
              expect(Array.isArray(vulns)).toBe(true);
              // Each package should have results (even if empty array)
              expect(vulns).toBeDefined();
            }

            // Verify OSV was called
            expect(osvGetBatchMock).toHaveBeenCalledTimes(1);
          }
        ),
        { numRuns: getPropertyTestRuns(50, 10) }
      );
    });

    it('should handle complete OSV failure gracefully by falling back to GitHub', async () => {
      await fc.assert(
        fc.asyncProperty(
          // Generate random dependencies
          fc.array(
            fc.record({
              name: fc.string({ minLength: 1, maxLength: 30 }),
              version: fc.string({ minLength: 1, maxLength: 20 }),
              versionConstraint: fc.string({ minLength: 1, maxLength: 20 }),
              isDev: fc.boolean(),
            }),
            { minLength: 1, maxLength: 20 }
          ),
          async (dependencies: Dependency[]) => {
            // GitHub provides results for all packages
            const githubResults = new Map<string, Vulnerability[]>();
            for (const dep of dependencies) {
              githubResults.set(dep.name, [
                {
                  id: `GHSA-${dep.name}`,
                  title: `GitHub vulnerability for ${dep.name}`,
                  severity: 'high',
                  affectedVersions: '< 3.0.0',
                  description: 'Test GitHub vulnerability',
                  references: [],
                  publishedDate: new Date(),
                  lastModifiedDate: new Date(),
                },
              ]);
            }

            // Create mock clients - OSV fails completely
            const osvGetBatchMock = vi.fn().mockRejectedValue(new Error('OSV service unavailable'));
            const githubGetBatchMock = vi.fn().mockResolvedValue(githubResults);

            const osvClient: VulnerabilityClient = {
              getVulnerabilities: vi.fn(),
              getBatchVulnerabilities: osvGetBatchMock,
            };

            const githubClient: VulnerabilityClient = {
              getVulnerabilities: vi.fn(),
              getBatchVulnerabilities: githubGetBatchMock,
            };

            const clients = new Map<VulnerabilitySource, VulnerabilityClient>([
              ['osv', osvClient],
              ['github', githubClient],
            ]);

            const aggregator = new VulnerabilityAggregator(
              clients,
              mockRequestQueue,
              mockOutputChannel,
              ['osv', 'github'],
              'osv'
            );

            // Execute batch query
            const results = await aggregator.getBatchAggregatedVulnerabilities(dependencies);

            // Verify results were returned from GitHub fallback
            expect(results).toBeDefined();
            // Results map uses package names as keys, so count unique names
            const uniquePackageNames = new Set(dependencies.map((d) => d.name)).size;
            expect(results.size).toBe(uniquePackageNames);

            // Verify all packages have results from GitHub
            for (const dep of dependencies) {
              expect(results.has(dep.name)).toBe(true);
              const vulns = results.get(dep.name);
              expect(vulns).toBeDefined();
              if (vulns) {
                expect(vulns.length).toBeGreaterThan(0);
                expect(vulns[0].sources).toContain('github');
              }
            }

            // Verify both clients were called
            expect(osvGetBatchMock).toHaveBeenCalledTimes(1);
            expect(githubGetBatchMock).toHaveBeenCalledTimes(1);
          }
        ),
        { numRuns: getPropertyTestRuns(50, 10) }
      );
    });

    it('should return empty results when both OSV and GitHub fail', async () => {
      await fc.assert(
        fc.asyncProperty(
          // Generate random dependencies
          fc.array(
            fc.record({
              name: fc.string({ minLength: 1, maxLength: 30 }),
              version: fc.string({ minLength: 1, maxLength: 20 }),
              versionConstraint: fc.string({ minLength: 1, maxLength: 20 }),
              isDev: fc.boolean(),
            }),
            { minLength: 1, maxLength: 20 }
          ),
          async (dependencies: Dependency[]) => {
            // Create mock clients - both fail
            const osvGetBatchMock = vi.fn().mockRejectedValue(new Error('OSV service unavailable'));
            const githubGetBatchMock = vi
              .fn()
              .mockRejectedValue(new Error('GitHub service unavailable'));

            const osvClient: VulnerabilityClient = {
              getVulnerabilities: vi.fn(),
              getBatchVulnerabilities: osvGetBatchMock,
            };

            const githubClient: VulnerabilityClient = {
              getVulnerabilities: vi.fn(),
              getBatchVulnerabilities: githubGetBatchMock,
            };

            const clients = new Map<VulnerabilitySource, VulnerabilityClient>([
              ['osv', osvClient],
              ['github', githubClient],
            ]);

            const aggregator = new VulnerabilityAggregator(
              clients,
              mockRequestQueue,
              mockOutputChannel,
              ['osv', 'github'],
              'osv'
            );

            // Execute batch query
            const results = await aggregator.getBatchAggregatedVulnerabilities(dependencies);

            // Verify results were returned (graceful degradation)
            expect(results).toBeDefined();
            // Results map uses package names as keys, so count unique names
            const uniquePackageNames = new Set(dependencies.map((d) => d.name)).size;
            expect(results.size).toBe(uniquePackageNames);

            // Verify all packages have empty results
            for (const dep of dependencies) {
              expect(results.has(dep.name)).toBe(true);
              const vulns = results.get(dep.name);
              expect(vulns).toBeDefined();
              if (vulns) {
                expect(vulns.length).toBe(0);
              }
            }

            // Verify both clients were called
            expect(osvGetBatchMock).toHaveBeenCalledTimes(1);
            expect(githubGetBatchMock).toHaveBeenCalledTimes(1);
          }
        ),
        { numRuns: getPropertyTestRuns(50, 10) }
      );
    });

    it('should handle mixed success and failure scenarios', async () => {
      await fc.assert(
        fc.asyncProperty(
          // Generate random dependencies (at least 3 for meaningful test)
          fc.array(
            fc.record({
              name: fc.string({ minLength: 1, maxLength: 30 }),
              version: fc.string({ minLength: 1, maxLength: 20 }),
              versionConstraint: fc.string({ minLength: 1, maxLength: 20 }),
              isDev: fc.boolean(),
            }),
            { minLength: 3, maxLength: 20 }
          ),
          async (dependencies: Dependency[]) => {
            // Create partial results - some packages succeed, some fail
            const osvResults = new Map<string, Vulnerability[]>();

            // First half succeeds
            const successCount = Math.floor(dependencies.length / 2);
            for (let i = 0; i < successCount; i++) {
              const dep = dependencies[i];
              osvResults.set(dep.name, [
                {
                  id: `CVE-2023-${i}`,
                  title: `Vulnerability for ${dep.name}`,
                  severity: 'medium',
                  affectedVersions: '< 2.0.0',
                  description: 'Test vulnerability',
                  references: [],
                  publishedDate: new Date(),
                  lastModifiedDate: new Date(),
                },
              ]);
            }

            // Create mock clients
            const osvGetBatchMock = vi.fn().mockResolvedValue(osvResults);
            const githubGetBatchMock = vi.fn().mockResolvedValue(new Map());

            const osvClient: VulnerabilityClient = {
              getVulnerabilities: vi.fn(),
              getBatchVulnerabilities: osvGetBatchMock,
            };

            const githubClient: VulnerabilityClient = {
              getVulnerabilities: vi.fn(),
              getBatchVulnerabilities: githubGetBatchMock,
            };

            const clients = new Map<VulnerabilitySource, VulnerabilityClient>([
              ['osv', osvClient],
              ['github', githubClient],
            ]);

            const aggregator = new VulnerabilityAggregator(
              clients,
              mockRequestQueue,
              mockOutputChannel,
              ['osv', 'github'],
              'osv'
            );

            // Execute batch query
            const results = await aggregator.getBatchAggregatedVulnerabilities(dependencies);

            // Verify results were returned
            expect(results).toBeDefined();
            expect(results.size).toBeGreaterThan(0);

            // Verify successful packages have results
            for (let i = 0; i < successCount; i++) {
              const dep = dependencies[i];
              expect(results.has(dep.name)).toBe(true);
              const vulns = results.get(dep.name);
              expect(vulns).toBeDefined();
              if (vulns) {
                expect(vulns.length).toBeGreaterThan(0);
              }
            }

            // Verify OSV was called
            expect(osvGetBatchMock).toHaveBeenCalledTimes(1);
          }
        ),
        { numRuns: getPropertyTestRuns(50, 10) }
      );
    });
  });
});
