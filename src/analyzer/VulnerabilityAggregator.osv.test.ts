import { beforeEach, describe, expect, it, vi } from 'vitest';
import type * as vscode from 'vscode';
import type { Dependency, Vulnerability, VulnerabilityClient, VulnerabilitySource } from '../types';
import type { RequestQueue } from '../utils/RequestQueue';
import { VulnerabilityAggregator } from './VulnerabilityAggregator';

// Mock output channel
const createMockOutputChannel = (): vscode.OutputChannel => ({
  name: 'test',
  append: vi.fn(),
  appendLine: vi.fn(),
  replace: vi.fn(),
  clear: vi.fn(),
  show: vi.fn(),
  hide: vi.fn(),
  dispose: vi.fn(),
});

// Mock request queue
const createMockRequestQueue = (): RequestQueue =>
  ({
    enqueue: vi.fn().mockImplementation((fn) => fn()),
    clear: vi.fn(),
    getQueueSize: vi.fn().mockReturnValue(0),
    getActiveCount: vi.fn().mockReturnValue(0),
  }) as unknown as RequestQueue;

// Mock vulnerability client
const createMockClient = (
  vulnerabilities: Map<string, Vulnerability[]>,
  shouldFail: boolean = false
): VulnerabilityClient => ({
  getVulnerabilities: vi.fn().mockImplementation(async (packageName: string) => {
    if (shouldFail) {
      throw new Error('API unavailable');
    }
    return vulnerabilities.get(packageName) || [];
  }),
  getBatchVulnerabilities: vi.fn().mockImplementation(async () => {
    if (shouldFail) {
      throw new Error('API unavailable');
    }
    return vulnerabilities;
  }),
});

describe('VulnerabilityAggregator - OSV Integration Tests', () => {
  let mockOutputChannel: vscode.OutputChannel;
  let mockRequestQueue: RequestQueue;

  beforeEach(() => {
    mockOutputChannel = createMockOutputChannel();
    mockRequestQueue = createMockRequestQueue();
  });

  describe('OSV to GitHub fallback', () => {
    it('should fallback to GitHub when OSV fails', async () => {
      const deps: Dependency[] = [
        { name: 'express', version: '4.17.1', versionConstraint: '4.17.1', isDev: false },
      ];

      const githubVulns = new Map([
        [
          'express',
          [
            {
              id: 'CVE-2021-1234',
              title: 'GitHub Advisory',
              severity: 'high' as const,
              affectedVersions: '< 4.17.2',
              description: 'Vulnerability from GitHub',
              references: [],
              publishedDate: new Date('2021-01-01'),
              lastModifiedDate: new Date('2021-01-02'),
              sources: ['github' as VulnerabilitySource],
            },
          ],
        ],
      ]);

      // OSV client that fails
      const osvClient = createMockClient(new Map(), true);
      // GitHub client that succeeds
      const githubClient = createMockClient(githubVulns, false);

      const clients = new Map<VulnerabilitySource, VulnerabilityClient>([
        ['osv', osvClient],
        ['github', githubClient],
      ]);

      // Only OSV in activeSources - GitHub should only be used as fallback
      const aggregator = new VulnerabilityAggregator(clients, mockRequestQueue, mockOutputChannel, [
        'osv',
      ]);

      const result = await aggregator.getBatchAggregatedVulnerabilities(deps);

      // Should have vulnerabilities from GitHub (fallback)
      expect(result.size).toBe(1);
      expect(result.has('express')).toBe(true);

      const vulns = result.get('express');
      expect(vulns).toBeDefined();
      expect(vulns?.length).toBe(1);
      expect(vulns?.[0]?.sources).toContain('github');
      expect(vulns?.[0]?.title).toBe('GitHub Advisory');

      // Verify logging shows fallback occurred
      const allLogs = vi
        .mocked(mockOutputChannel.appendLine)
        .mock.calls.map((call) => call[0])
        .join('\n');
      expect(allLogs.toLowerCase()).toContain('error');
    });

    it('should prefer OSV when it succeeds and not query GitHub', async () => {
      const deps: Dependency[] = [
        { name: 'lodash', version: '4.17.20', versionConstraint: '4.17.20', isDev: false },
      ];

      const osvVulns = new Map([
        [
          'lodash',
          [
            {
              id: 'CVE-2021-1111',
              title: 'OSV Vulnerability',
              severity: 'high' as const,
              affectedVersions: '< 4.17.21',
              description: 'From OSV',
              references: [],
              publishedDate: new Date('2021-01-01'),
              lastModifiedDate: new Date('2021-01-02'),
              sources: ['osv' as VulnerabilitySource],
              cvssScore: 7.5,
              cvssVersion: '3.1',
              vectorString: 'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H',
            },
          ],
        ],
      ]);

      const githubVulns = new Map([
        [
          'lodash',
          [
            {
              id: 'CVE-2021-1111',
              title: 'GitHub Advisory',
              severity: 'high' as const,
              affectedVersions: '< 4.17.21',
              description: 'From GitHub',
              references: [],
              publishedDate: new Date('2021-01-01'),
              lastModifiedDate: new Date('2021-01-02'),
              sources: ['github' as VulnerabilitySource],
            },
          ],
        ],
      ]);

      const osvClient = createMockClient(osvVulns, false);
      const githubClient = createMockClient(githubVulns, false);

      const clients = new Map<VulnerabilitySource, VulnerabilityClient>([
        ['osv', osvClient],
        ['github', githubClient],
      ]);

      // Only OSV in activeSources - GitHub should only be used as fallback
      const aggregator = new VulnerabilityAggregator(clients, mockRequestQueue, mockOutputChannel, [
        'osv',
      ]);

      const result = await aggregator.getBatchAggregatedVulnerabilities(deps);

      expect(result.size).toBe(1);
      const vulns = result.get('lodash');
      expect(vulns).toBeDefined();

      // Should only have OSV results (GitHub not queried when OSV succeeds)
      expect(vulns?.length).toBe(1);
      expect(vulns?.[0]?.sources).toContain('osv');

      // Should have CVSS data from OSV
      expect(vulns?.[0]?.cvssScore).toBe(7.5);
      expect(vulns?.[0]?.cvssVersion).toBe('3.1');

      // Verify GitHub was NOT called (fallback not triggered)
      expect(githubClient.getBatchVulnerabilities).not.toHaveBeenCalled();
    });

    it('should return empty results when both OSV and GitHub fail', async () => {
      const deps: Dependency[] = [
        { name: 'test', version: '1.0.0', versionConstraint: '1.0.0', isDev: false },
      ];

      // Both clients fail
      const osvClient = createMockClient(new Map(), true);
      const githubClient = createMockClient(new Map(), true);

      const clients = new Map<VulnerabilitySource, VulnerabilityClient>([
        ['osv', osvClient],
        ['github', githubClient],
      ]);

      // Only OSV in activeSources - GitHub should only be used as fallback
      const aggregator = new VulnerabilityAggregator(clients, mockRequestQueue, mockOutputChannel, [
        'osv',
      ]);

      const result = await aggregator.getBatchAggregatedVulnerabilities(deps);

      // Should return map with empty arrays for packages (graceful degradation)
      expect(result.size).toBe(1);
      expect(result.get('test')).toEqual([]);

      // Verify error logging
      const allLogs = vi
        .mocked(mockOutputChannel.appendLine)
        .mock.calls.map((call) => call[0])
        .join('\n');
      expect(allLogs.toLowerCase()).toContain('error');
    });

    it('should log fallback reason', async () => {
      const deps: Dependency[] = [
        { name: 'test', version: '1.0.0', versionConstraint: '1.0.0', isDev: false },
      ];

      const githubVulns = new Map([['test', []]]);

      const osvClient = createMockClient(new Map(), true);
      const githubClient = createMockClient(githubVulns, false);

      const clients = new Map<VulnerabilitySource, VulnerabilityClient>([
        ['osv', osvClient],
        ['github', githubClient],
      ]);

      // Only OSV in activeSources - GitHub should only be used as fallback
      const aggregator = new VulnerabilityAggregator(clients, mockRequestQueue, mockOutputChannel, [
        'osv',
      ]);

      await aggregator.getBatchAggregatedVulnerabilities(deps);

      // Check logs for fallback indication
      const allLogs = vi
        .mocked(mockOutputChannel.appendLine)
        .mock.calls.map((call) => call[0])
        .join('\n');

      // Should mention error or failure
      expect(allLogs.length).toBeGreaterThan(0);
    });
  });

  describe('Configuration-driven source selection', () => {
    it('should use OSV as primary source when configured', async () => {
      const deps: Dependency[] = [
        { name: 'test', version: '1.0.0', versionConstraint: '1.0.0', isDev: false },
      ];

      const osvVulns = new Map([
        [
          'test',
          [
            {
              id: 'CVE-2021-1234',
              title: 'OSV Vuln',
              severity: 'high' as const,
              affectedVersions: '< 2.0.0',
              description: 'Test',
              references: [],
              publishedDate: new Date(),
              lastModifiedDate: new Date(),
              sources: ['osv' as VulnerabilitySource],
            },
          ],
        ],
      ]);

      const osvClient = createMockClient(osvVulns, false);

      const clients = new Map<VulnerabilitySource, VulnerabilityClient>([['osv', osvClient]]);

      // Only OSV in source list
      const aggregator = new VulnerabilityAggregator(clients, mockRequestQueue, mockOutputChannel, [
        'osv',
      ]);

      const result = await aggregator.getBatchAggregatedVulnerabilities(deps);

      expect(result.size).toBe(1);
      const vulns = result.get('test');
      expect(vulns).toBeDefined();
      expect(vulns?.[0]?.sources).toContain('osv');
    });

    it('should use GitHub as primary source when OSV is disabled', async () => {
      const deps: Dependency[] = [
        { name: 'test', version: '1.0.0', versionConstraint: '1.0.0', isDev: false },
      ];

      const githubVulns = new Map([
        [
          'test',
          [
            {
              id: 'CVE-2021-5678',
              title: 'GitHub Vuln',
              severity: 'medium' as const,
              affectedVersions: '< 2.0.0',
              description: 'Test',
              references: [],
              publishedDate: new Date(),
              lastModifiedDate: new Date(),
              sources: ['github' as VulnerabilitySource],
            },
          ],
        ],
      ]);

      const githubClient = createMockClient(githubVulns, false);

      const clients = new Map<VulnerabilitySource, VulnerabilityClient>([['github', githubClient]]);

      // Only GitHub in source list
      const aggregator = new VulnerabilityAggregator(clients, mockRequestQueue, mockOutputChannel, [
        'github',
      ]);

      const result = await aggregator.getBatchAggregatedVulnerabilities(deps);

      expect(result.size).toBe(1);
      const vulns = result.get('test');
      expect(vulns).toBeDefined();
      expect(vulns?.[0]?.sources).toContain('github');
    });

    it('should only use OSV when it returns results', async () => {
      const deps: Dependency[] = [
        { name: 'package', version: '1.0.0', versionConstraint: '1.0.0', isDev: false },
      ];

      const osvVulns = new Map([
        [
          'package',
          [
            {
              id: 'CVE-2021-AAAA',
              title: 'OSV Only',
              severity: 'high' as const,
              affectedVersions: '< 2.0.0',
              description: 'From OSV',
              references: [],
              publishedDate: new Date(),
              lastModifiedDate: new Date(),
              sources: ['osv' as VulnerabilitySource],
            },
            {
              id: 'CVE-2021-SHARED',
              title: 'Shared Vuln',
              severity: 'critical' as const,
              affectedVersions: '< 2.0.0',
              description: 'Found in both',
              references: [],
              publishedDate: new Date(),
              lastModifiedDate: new Date(),
              sources: ['osv' as VulnerabilitySource],
              cvssScore: 9.8,
              cvssVersion: '3.1',
            },
          ],
        ],
      ]);

      const githubVulns = new Map([
        [
          'package',
          [
            {
              id: 'CVE-2021-BBBB',
              title: 'GitHub Only',
              severity: 'medium' as const,
              affectedVersions: '< 2.0.0',
              description: 'From GitHub',
              references: [],
              publishedDate: new Date(),
              lastModifiedDate: new Date(),
              sources: ['github' as VulnerabilitySource],
            },
            {
              id: 'CVE-2021-SHARED',
              title: 'Shared Vuln',
              severity: 'critical' as const,
              affectedVersions: '< 2.0.0',
              description: 'Found in both',
              references: [],
              publishedDate: new Date(),
              lastModifiedDate: new Date(),
              sources: ['github' as VulnerabilitySource],
            },
          ],
        ],
      ]);

      const osvClient = createMockClient(osvVulns, false);
      const githubClient = createMockClient(githubVulns, false);

      const clients = new Map<VulnerabilitySource, VulnerabilityClient>([
        ['osv', osvClient],
        ['github', githubClient],
      ]);

      // Only OSV in activeSources - GitHub should only be used as fallback
      const aggregator = new VulnerabilityAggregator(clients, mockRequestQueue, mockOutputChannel, [
        'osv',
      ]);

      const result = await aggregator.getBatchAggregatedVulnerabilities(deps);

      const vulns = result.get('package');
      expect(vulns).toBeDefined();

      // Should only have OSV vulnerabilities (GitHub not queried when OSV succeeds)
      expect(vulns?.length).toBe(2);

      // Find CVEs
      const cveIds = vulns?.map((v) => v.id) ?? [];
      expect(cveIds).toContain('CVE-2021-AAAA'); // OSV only
      expect(cveIds).toContain('CVE-2021-SHARED'); // OSV
      expect(cveIds).not.toContain('CVE-2021-BBBB'); // GitHub not queried

      // Should preserve CVSS data from OSV
      const sharedVuln = vulns?.find((v) => v.id === 'CVE-2021-SHARED');
      expect(sharedVuln).toBeDefined();
      expect(sharedVuln?.cvssScore).toBe(9.8);
      expect(sharedVuln?.cvssVersion).toBe('3.1');

      // Verify GitHub was not called
      expect(githubClient.getBatchVulnerabilities).not.toHaveBeenCalled();
    });
  });

  describe('Primary source preference', () => {
    it('should use OSV when it has data (no GitHub query)', async () => {
      const deps: Dependency[] = [
        { name: 'package', version: '1.0.0', versionConstraint: '1.0.0', isDev: false },
      ];

      // OSV has CVSS data
      const osvVulns = new Map([
        [
          'package',
          [
            {
              id: 'CVE-2021-12345',
              title: 'Vulnerability',
              severity: 'high' as const,
              affectedVersions: '< 2.0.0',
              description: 'Test',
              references: [],
              publishedDate: new Date(),
              lastModifiedDate: new Date(),
              sources: ['osv' as VulnerabilitySource],
              cvssScore: 8.5,
              cvssVersion: '3.1',
              vectorString: 'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H',
            },
          ],
        ],
      ]);

      // GitHub has data but won't be queried
      const githubVulns = new Map([
        [
          'package',
          [
            {
              id: 'CVE-2021-12345',
              title: 'Vulnerability',
              severity: 'high' as const,
              affectedVersions: '< 2.0.0',
              description: 'Test',
              references: [],
              publishedDate: new Date(),
              lastModifiedDate: new Date(),
              sources: ['github' as VulnerabilitySource],
            },
          ],
        ],
      ]);

      const osvClient = createMockClient(osvVulns, false);
      const githubClient = createMockClient(githubVulns, false);

      const clients = new Map<VulnerabilitySource, VulnerabilityClient>([
        ['osv', osvClient],
        ['github', githubClient],
      ]);

      // Only OSV in activeSources - GitHub should only be used as fallback
      const aggregator = new VulnerabilityAggregator(clients, mockRequestQueue, mockOutputChannel, [
        'osv',
      ]);

      const result = await aggregator.getBatchAggregatedVulnerabilities(deps);

      const vulns = result.get('package');
      expect(vulns).toBeDefined();
      const vuln = vulns?.find((v) => v.id === 'CVE-2021-12345');

      expect(vuln).toBeDefined();
      expect(vuln?.sources).toContain('osv');

      // Should have CVSS data from OSV
      expect(vuln?.cvssScore).toBe(8.5);
      expect(vuln?.cvssVersion).toBe('3.1');
      expect(vuln?.vectorString).toContain('CVSS:3.1/');

      // Verify GitHub was NOT queried
      expect(githubClient.getBatchVulnerabilities).not.toHaveBeenCalled();
    });

    it('should use OSV CVSS scores when configured as primary', async () => {
      const deps: Dependency[] = [
        { name: 'package', version: '1.0.0', versionConstraint: '1.0.0', isDev: false },
      ];

      // OSV has CVSS v3.1
      const osvVulns = new Map([
        [
          'package',
          [
            {
              id: 'CVE-2021-99999',
              title: 'Vuln',
              severity: 'critical' as const,
              affectedVersions: '< 2.0.0',
              description: 'Test',
              references: [],
              publishedDate: new Date(),
              lastModifiedDate: new Date(),
              sources: ['osv' as VulnerabilitySource],
              cvssScore: 9.8,
              cvssVersion: '3.1',
              vectorString: 'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H',
            },
          ],
        ],
      ]);

      // GitHub has different CVSS
      const githubVulns = new Map([
        [
          'package',
          [
            {
              id: 'CVE-2021-99999',
              title: 'Vuln',
              severity: 'high' as const,
              affectedVersions: '< 2.0.0',
              description: 'Test',
              references: [],
              publishedDate: new Date(),
              lastModifiedDate: new Date(),
              sources: ['github' as VulnerabilitySource],
              cvssScore: 7.5,
              cvssVersion: '3.0',
            },
          ],
        ],
      ]);

      const osvClient = createMockClient(osvVulns, false);
      const githubClient = createMockClient(githubVulns, false);

      const clients = new Map<VulnerabilitySource, VulnerabilityClient>([
        ['osv', osvClient],
        ['github', githubClient],
      ]);

      // Only OSV in activeSources - GitHub should only be used as fallback
      const aggregator = new VulnerabilityAggregator(clients, mockRequestQueue, mockOutputChannel, [
        'osv',
      ]);

      const result = await aggregator.getBatchAggregatedVulnerabilities(deps);

      const vulns = result.get('package');
      expect(vulns).toBeDefined();
      const vuln = vulns?.find((v) => v.id === 'CVE-2021-99999');

      // Should have OSV data (GitHub not queried)
      expect(vuln).toBeDefined();
      expect(vuln?.cvssScore).toBe(9.8);
      expect(vuln?.cvssVersion).toBe('3.1');
      expect(vuln?.severity).toBe('critical');

      // Verify GitHub was not queried
      expect(githubClient.getBatchVulnerabilities).not.toHaveBeenCalled();
    });
  });
});
